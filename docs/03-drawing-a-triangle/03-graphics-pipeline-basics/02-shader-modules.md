不同于早期的API，Vulkan中的着色器代码必须以字节码格式指定，而不像[GLSL](https://en.wikipedia.org/wiki/OpenGL_Shading_Language)和[HLSL](https://en.wikipedia.org/wiki/High-Level_Shading_Language)这样具有可读语法的着色器语言。这种字节码格式被称作[SPIR-V](https://www.khronos.org/spir)，设计用于 Vulkan 和OpenCL (两者都属 Khronos 的 API)。这种格式用于编写图形着色器和计算着色器，但是在本教程中，我们只需要关注在Vulkan图形管线中使用的的着色器。

GPU厂商编写的编译器可以将着色器代码编译为二进制代码，而使用字节码格式的一大优势在于，可以显著地简化编译器的编译过程。根据过去的经验，对于 GLSL 这样可读性比较强的语言，一些 GPU 厂商可能在实现 API 标准的时候夹带私货，如果你按照某一家厂商的标准写着色器，有可能在另外一家厂商的 GPU 上却会无法编译或无法运行。使用像 SPIR-V 这样简单直接的字节码将会有效地避免这些风险。

然而，这并不意味着我们需要手写二进制字节码。Khronos 发布了自己的独立于 GPU 厂商的编译器，用于将 GLSL 编译为 SPIR-V。编译器在将 GLSL 编译成 SPIR-V 二进制文件的同时还能检验着色器代码是否符合标准。你可以在程序运行时将编译器作为一个库来生成SPIR-V文件，但是我们在本教程中不会这么做。虽然我们可以直接使用 `glslagvalidator.exe` 来编译着色器，但 Google 为我们提供了更好的选择 ----- `glslc.exe`。`glslc` 的优点是，它具有与 GCC 和 Clang 等编译器相同的参数格式，并包含一些额外的功能，如 *includes* 。Vulkan SDK 已经提供了这些工具，你不需要下载任何额外的东西。

GLSL 和 C 语言编程风格很类似，理所当然，程序是从 main 函数开始执行的。不过 GLSL 可不使用命令行参数来处理输入输出，取而代之的是定义用于输入输出的全局变量。另外，GLSL 还提供了内置的线性代数库来辅助图形编程，如点积、叉积等各种线性代数运算。向量类型称为 `vec`，带有一个数字来表示元素的数量。例如，三维位置将存储在`vec3`中。可以通过像`.x`这样的方式去访问单个元素，也可以同时使用多个元素创建一个新的向量。例如，表达式`vec3(1.0, 2.0, 3.0).xy`将生成 `vec2`。向量的构造函数也可以采用向量对象和标量值的组合。例如，`vec3`可以用`vec3(vec2(1.0, 2.0), 3.0)`构造。

如同之前的章节提到的，为了三角形显示在屏幕上，我们需要编写一个顶点着色器和一个片段着色器。接下来两节的内容将会包含这两个着色器的GLSL代码，之后我们还需要分别将顶点着色器和片段着色器编译成两个 SPIR-V 文件。

## 顶点着色器

顶点着色器功能如其名，它针对每一个顶点，处理其属性(如位置、法线、纹理坐标)，计算顶点在裁剪坐标系中的最终位置，并将属性值传递给光栅化器，然后这些值会在光栅化时在片元之间平滑插值。

*裁剪坐标*(*clip coordinate*)由顶点着色器输出，它是一个具有四个维度的向量。我们把裁剪坐标除以它的最后一个元素可以得到*标准化设备坐标*(*normalized device coordinate*)。而标准化设备坐标属于[齐次坐标](https://en.wikipedia.org/wiki/Homogeneous_coordinates)(*homogeneous coordinate*)，标准化设备坐标经过视口变化以后，将帧缓冲区映射到了一个[-1, 1] × [-1, 1]的坐标系，如下所示：

![](/images/normalized_device_coordinates.svg)

如果你之前接触过计算机图形学，那么相信上面说的这些对你来说肯定是小菜一碟。细心的你肯定能发现，Vulkan 与 OpenGL 相比，Y 轴是翻转的。OpenGL 的屏幕空间原点在左下，而 Vulkan 的空间远点则是左上，与DirectX相同。

鉴于这是我们的第一个三角形，我们需要循序渐进序。我们将不会应用任何坐标变换，而是直接把三个顶点的位置输出到标准化设备坐标，来创建下面的三角形：

![](/images/triangle.png)

通过把顶点着色器输出的裁剪坐标的最后一个向量元素设置为1，我们可以直接输出标准化设备坐标。这样的话，将裁剪坐标转换为标准化设备坐标的除法运算不会造成任何变化。

通常来说这些顶点坐标数据会被存储在一个顶点缓冲里面，顶点着色器再从顶点缓冲中读取顶点数据。但是，在Vulkan中创建一个顶点缓冲并将数据填入其中并不是一件简单的事情。所以，我们稍后再看这部分该怎么做，眼下，我们只需要把注意力放在我们的第一个三角形上即可。同时，我们还要做一件有悖常规的事情 —— 把坐标硬编码进着色器中，这样我们可以快速地得到结果。代码如下：

```glsl
#version 450

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec3(-0.5, 0.5)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
}
```

每个顶点都会调用一次 `main` 函数。内置变量 `gl_VertexIndex` 包含了当前顶点的索引。这通常是顶点缓冲区的索引，但在我们的例子中，它将会是硬编码顶点数据数组的索引。顶点的位置从着色器的常量数组中取得，得到一个二维向量，与 `y` 和 `w` 元素组合后生成了裁剪坐标向量。内置变量 `gl_Position` 则是作为输出。

## 片段着色器

顶点着色器输出的位置组成了一系列三角形，而三角形会被光栅化成不同的片段(也即像素点)，片段将会一片片地将屏幕填满。每一个片段都会经过片段着色器的处理，为帧缓冲生成颜色与深度值。一个将整个三角形的片段染成红色的片段着色器代码如下：

```glsl
#version450
#extension GL_ARB_separate_shader_object : enable

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

正如每个顶点着色器的 `main` 函数会为每个顶点调用一样，每个片段着色器的 `main` 函数也会为每个片段而调用。GLSL中的颜色值是一个四维向量，在[0, 1]的范围内分别代表R、G、B和透明通道。不同于顶点着色器的 `gl_Position`，片段着色器中并没有内置变量来为当前的片段输出颜色值。你必须为每一个帧缓冲指定你自己的输出变量，而`layout(location = 0)` 限定符指定了帧缓冲的索引。红色值通过 outColor 写入帧缓冲的第0个渲染目标(在此例中仅1个)。

## 逐顶点颜色

让整个三角形都显示红色不是那么有趣，下面的三角形不是看起来更加有意思一些吗？

![](/images/triangle_coordinates_colors.png)

为了实现这个效果，我们必须对两个着色器都做一些改变。首先，我们需要为三个顶点指定一个不同的颜色。顶点着色器现在应该包含一个含有颜色值的数组，就像位置数组一样：

```glsl
vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);
```

现在，我们只需要把每个顶点的颜色传入片段着色器中，以便于片段着色器能向帧缓冲区输出它们的插值。向顶点着色器添加一个颜色输出，并将其写入`main`函数中：

```glsl
layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

接下来，我们需要在片段着色器中添加一个相应的输入变量：

```glsl
layout(location = 0) in fragColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

输入变量的名字不必和输出变量一样，它们会通过由`location`指示符指定的索引值链接到一起。片段着色器中的`main`函数做了一定的修改，输出的颜色值加上了一个alpha值。如同上面的图片所显示的那样，`fragColor`的值会自动地在三个顶点之间进行插值，形成了一个平滑的梯度。

## 编译着色器