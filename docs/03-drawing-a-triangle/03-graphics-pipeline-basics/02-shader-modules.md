不同于早期的API，Vulkan中的着色器代码必须以字节码格式指定，而不像[GLSL](https://en.wikipedia.org/wiki/OpenGL_Shading_Language)和[HLSL](https://en.wikipedia.org/wiki/High-Level_Shading_Language)这样具有可读语法的着色器语言。这种字节码格式被称作[SPIR-V](https://www.khronos.org/spir)，设计用于Vulkan和OpenCL(两者都属于Khronos的API)。这种格式用于编写图形着色器和计算着色器，但是在本教程中，我们将把注意力集中于在Vulkan图形管线中使用的的着色器。

使用字节码格式的一大优势在于，显著地简化了GPU厂商编写的，用于将着色器代码编译为原生代码的编译器。过去的经验表明，对于GLSL这样的人类可读语言，一些GPU厂商对标准的解释相当灵活。如果你碰巧使用其中一家厂商的GPU编写了重要的着色器，那么你将面临其他厂商的驱动程序由于语法错误而拒绝你的代码的风险，或者更糟，你的着色器会由于编译器错误而与预料中的运行不一致。使用像SPIR-V这样简单直接的字节码将会有效地避免这些风险。

然而，这并不意味着我们需要手动编写二进制字节码。Khronos发布了自己的独立于GPU厂商的编译器，用于将GLSL编译为SPIR-V。编译器用于验证着色器代码是否完全符合标准，并生成一个可传入程序的SPIR-V二进制文件。你可以在程序运行时将编译器作为一个库来生成SPIR-V文件，但是我们在本教程中不会这么做。虽然我们可以通过`glslagvalidator.exe`直接使用编译器，但我们将通过Google来使用`glslc.exe`。`glslc`的优点是，它具有与GCC和Clang等编译器相同的参数格式，并包含一些额外的功能，如*includes*。它们都已经包含在Vulkan SDK中，所以你不需要下载任何额外的东西。

GLSL是一种具有C风格语法的着色器语言，用它编写的程序有一个`main`函数，可以被每个对象调用。不同于使用参数输入和返回值输出，GLSL采用全局变量来处理输入和输出。它包含许多功能来辅助图形编程，如内置向量和素矩阵。还包含了用于矩阵运算的函数，像叉积，矩阵向量积和围绕向量的反射运算。向量类型称为`vec`，带有一个数字来表示元素的数量。例如，三维位置将存储在`vec3`中。可以通过像`.x`这样的方式去访问单个元素，也可以同时使用多个元素创建一个新的向量。例如，表达式`vec3(1.0, 2.0, 3.0).xy`将生成`vec2`。向量的构造函数也可以采用向量对象和标量值的组合。例如，`vec3`可以用`vec3(vec2(1.0, 2.0), 3.0)`构造。

如同之前的章节提到的，为了三角形显示在屏幕上，我们需要编写一个顶点着色器和一个片段着色器。接下来两节的内容将会包含这两个着色器的GLSL代码，之后我还将向你们展示，如何生成两个SPIR-V二进制文件，并将它们加载到程序当中。

## 顶点着色器

顶点着色器处理每一个即将到来的顶点。它将顶点的属性，诸如世界坐标、颜色、法线还有纹理坐标，作为输入。裁剪坐标系中的最终位置，需要传给片段着色器的属性(颜色和纹理坐标)则作为输出。然后，这些值将会被光栅器插值到片段中，以生成一个平滑的梯度。

*裁剪坐标*(*clip coordinate*)是由顶点着色器输出的具有四个维度的向量，随后把整个向量除以向量的最后一个元素可以得到*标准化设备坐标*(*normalized device coordinate*)。标准化设备坐标属于[齐次坐标](https://en.wikipedia.org/wiki/Homogeneous_coordinates)(*homogeneous coordinate*)，这些坐标将帧缓冲区映射到了一个[-1, 1] × [-1, 1]的坐标系，如下所示：

![](/images/normalized_device_coordinates.svg)

如果你之前接触过计算机图形学，那么你应该已经熟悉了这些内容。如果你之前使用过OpenGL，你将会发现，Y坐标的符号翻转了过来。而Z坐标则使用和Direct3D相同的取值范围，从0到1。

鉴于这是我们的第一个三角形，我们将不会应用任何变换，仅仅只是直接把标准化设备坐标指定为三个顶点的位置，来创建下面的三角形：

![](/images/triangle.png)

通过把顶点着色器输出的裁剪坐标的最后一个向量元素设置为1，我们可以直接输出标准化设备坐标。这样的话，将裁剪坐标转换为标准化设备坐标的除法运算不会造成任何变化。

通常来说这些坐标会被存储在一个顶点缓冲里面，但是在Vulkan中创建一个顶点缓冲并将数据填入其中并不是一件简单的事情。所以，我决定延后介绍这部分内容，直到我们满意地看见一个三角形弹出在屏幕上。同时，我们将做一些稍微不太常规的事情：直接把坐标放入顶点着色器中。代码如下：

```glsl
#version 450

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec3(-0.5, 0.5)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
}
```

每个顶点都会调用一次`main`函数。内置变量`gl_VertexIndex`包含了当前顶点的索引。这通常是顶点缓冲区的索引，但在我们的例子中，它将会是硬编码顶点数据数组的索引。每个顶点的位置从着色器的常量数组中取得，通过与伪造的`y`和`w`元素组合，生成了裁剪坐标系中位置。内置变量`gl_Position`作为输出。

## 片段着色器

顶点着色器输出的位置形成了三角形，而该三角形通过片段(也即像素点)填充了屏幕的一块区域。片段着色器在这些片段上被调用，为帧缓冲区生成颜色和深度。一个为整个三角形输出红色的简单片段着色器代码如下：

```glsl
#version450
#extension GL_ARB_separate_shader_object : enable

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

正如每个顶点着色器的`main`函数会为每个顶点调用一样，每个片段着色器的`main`函数也会为每个片段而调用。GLSL中的颜色是一个四元素向量，在[0, 1]的范围内分别代表R、G、B和透明通道。不同于顶点着色器的`gl_Position`，并没有内置变量来为当前的片段输出颜色。你必须为每一个帧缓冲指定你自己的输出变量，`layout(location = 0)`修饰语指定了帧缓冲的索引。红色被写入了这个`outColor`变量，这个变量与索引为`0`的第一个(也是唯一的一个)帧缓冲链接到一起。

## 逐顶点颜色

让整个三角形都显示红色不是那么有趣，下面的三角形不是看起来更加有意思一些吗？

![](/images/triangle_coordinates_colors.png)

为了实现这个效果，我们必须对两个着色器都做一些改变。首先，我们需要为三个顶点指定一个不同的颜色。顶点着色器现在应该包含一个含有颜色值的数组，就像位置数组一样：

```glsl
vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);
```

现在，我们只需要把每个顶点的颜色传入片段着色器中，以便于片段着色器能向帧缓冲区输出它们的插值。向顶点着色器添加一个颜色输出，并将其写入`main`函数中：

```glsl
layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

接下来，我们需要在片段着色器中添加一个相应的输入变量：

```glsl
layout(location = 0) in fragColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

输入变量的名字不必和输出变量一样，它们会通过由`location`指示符指定的索引值链接到一起。片段着色器中的`main`函数做了一定的修改，输出的颜色值加上了一个alpha值。如同上面的图片所显示的那样，`fragColor`的值会自动地在三个顶点之间进行插值，形成了一个平滑的梯度。

## 编译着色器